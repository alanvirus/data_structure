k为桶数量
          时间复杂度          空间复杂度        适用场景
桶排序     O(n+nlogn-nlogk+K)   O(n+k)           元素均匀分布
计数排序   O(n+maxV-minV)     O(n+maxV-minV)   maxV-minV很小，元素分布密集
基数排序   O(dn)              O(n+k)           1.非负整数或可以作为非负整数比较 2.maxV-minV很小（让d小一点）
（对于基数排序，使用二进制，d最大，k=2最小，此时O(nd)很可能还不如O(nlogn);使用maxV做基数，k=maxV最大，d=1最小，此时退化为计数排序）

n为总数，M为取值集合大小
n>>M时适用桶排序，时空复杂度O(n),采用call-by-rank，突破了基于key比较的CBA式算法下界

计数排序适用于有多个字段且按字典序排列作为关键码的情况，得益于桶排序的稳定性，基数排序可以实现，且基数排序同样稳定
复杂度:O(n+M1)+...+O(n+Mt)=O(t*(n+M))

对[0,n^d)中的n个整数排序(d为常数)，要求O(n):
转为n进制，基数排序，复杂度为O(dn)=O(n)

计数排序:每个元素的秩等于小于它的元素个数(雷同元素要看原序列中位于它之前的雷同元素个数)
创建ht M大于等于元素取值范围宽度,初始化为0
H(A[k])++//或者H(hash(A[k]))++(hash不发生冲突)
H[i+1]+=H[i]
倒序遍历A
S[--H(A[k])]=A[k]
返回S
