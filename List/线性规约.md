算法时间复杂度度量：
具体输入不同，运行时间也不同；
其中，重点关注运行时间随输入规模的变化，记为T(n)
T(n)可能随具体输入变化而变化，可以取最大者

考虑求整数n素因子分解，使用bf从2-n挨个试，
如果n为素数，T(n)=n-1
如果n为2的幂，T(n)=log2(n)
可以看出T（n）随规模变化而上下波动，一般而言是单调递增的

T(n)的计算：
实际环境中测量(no)
将算法理解为图灵机+RAM等模型下的一系列指令，指令可分解为若干基本操作，基本操作在常数时间内完成，那么T(n)可定义为基本操作总次数

那么算法可能在特定输入规模上比其他算法好，重点关注***规模足够大***时的算法复杂度，也就是asymptotic analysis
T(n)=big-O（f(n)）：存在c使得n足够大时，T(n)<=cf(n) f(n)复杂度上界   c>0,O(f(n))=O(cf(n)); a>b>0,O(n^a+n^b)=O(n^a) 保留最高次项并忽略常系数
T(n)=big-omega(g(n)): 存在c使得n足够大时，T(n)>=cg(n) g(n)复杂度下界
上界==下界时,算法在输入规模足够大时用时稳定，记为T(n)=big-theta(h(n)) 规模较小时随意
small-o:           任意c，n足够大时，T(n)< cf(n) 真上界，取不到的上界
small-omega：      任意c，n足够大时，T(n)>cg(n)  真下界，取不到的下界

平均运行时间：按照某种假定的概率分布求平均运行时间，故又名期望运行时间
amortized运行时间：一个真实可行且足够长的操作序列，将运行时间分摊至所有操作 
e.g. 插入操作的平均时间复杂度为O(n) 假设的某种条件下用时平均为O(n)；分摊时间复杂度O(n):连续足够多次的插入平均为O(n) 二者互不蕴含，后者更可靠
    对于可扩容插入操作来说，需要扩容情况出现的概率会趋于0，不使用平均复杂度
    对于一个二进制表示的整数计数器，计数引起的比特位反转分摊来看是O（1）的
问题的复杂度下界(lower bound)：该问题在最坏情况下的最低计算成本,算法达到这一下界则称为最坏情况下最优的(worst-case optimal)


CBA式算法在问题最坏情况下的最低执行成本：
如果一个算法中的分支都来自于变量常量们的比较或比对，那么可以用比较树(comparison tree)表示，入口处为算法起始状态，每个内部节点代表比较或比对，叶节点表示算法终止状态
那么运行算法的一次运行时间将取决于到达叶节点的深度，最坏情况下的运行时间取决于最大深度(定义为树的高度)
哪个算法成本最坏情况下成本最低？寻找树高最小的比较树
可以找到一个下界：比对的情况下：h的树最多2^h个叶节点，因此如果该问题输出结果不少于N种，那么叶节点一定不少于N个，一定有h不小于 log_2(N)向上取整
                比较的情况下:三叉树，h不小于 log_3(N)向上取整
排序问题有n!种结果，利用stirling逼近得h=big-Omega(nlogn),仅针对CBA式算法

问题的复杂度下界仅针对最坏情况，最好情况多好都行


线性规约
求解问题B的复杂度：
求解A问题的最好算法有复杂度下界f(n)且big-omega(f(n))=small-omega(n),
并且A的输入可在线性时间内变为B的输入，B的输出可在线性时间内变成A的输出
那么B问题的最优算法的复杂度有下界f(n)

应用：已知元素唯一性问题有复杂度下界big-omega(nlogn),
将一堆实数元素组织为无序向量或列表为O(n)的，无序向量或列表唯一化后判断是否元素唯一是O(n)的
故无序向量或列表唯一化问题有复杂度下界big-omega(nlogn)
sort+uniquify是一种取到该下界的算法