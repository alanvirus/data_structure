算法时间复杂度度量：
具体输入不同，运行时间也不同；
其中，重点关注运行时间随输入规模的变化，记为T(n)
T(n)可能随具体输入变化而变化，可以取最大者

考虑求整数n素因子分解，使用bf从2-n挨个试，
如果n为素数，T(n)=n-1
如果n为2的幂，T(n)=log2(n)
可以看出T（n）随规模变化而上下波动，一般而言是单调递增的

T(n)的计算：
实际环境中测量(no)
将算法理解为图灵机+RAM等模型下的一系列指令，指令可分解为若干基本操作，基本操作在常数时间内完成，那么T(n)可定义为基本操作总次数

那么算法可能在特定输入规模上比其他算法好，重点关注***规模足够大***时的算法复杂度，也就是asymptotic analysis
T(n)=big-O（f(n)）：存在c使得n足够大时，T(n)<=cf(n) f(n)复杂度上界   c>0,O(f(n))=O(cf(n)); a>b>0,O(n^a+n^b)=O(n^a) 保留最高次项并忽略常系数
T(n)=big-omega(g(n)): 存在c使得n足够大时，T(n)>=cg(n) g(n)复杂度下界
上界==下界时,算法在输入规模足够大时用时稳定，记为T(n)=big-theta(h(n)) 规模较小时随意
small-o:           任意c，n足够大时，T(n)< cf(n) 真上界，取不到的上界
small-omega：      任意c，n足够大时，T(n)>cg(n)  真下界，取不到的下界

求解问题B的复杂度：
求解A问题的最好算法有复杂度下界f(n)且big-omega(f(n))=small-omega(n),
并且A的输入可在线性时间内变为B的输入，B的输出可在线性时间内变成A的输出
那么B问题的最优算法的复杂度有下界f(n)

应用：已知元素唯一性问题有复杂度下界big-omega(nlogn),
将一堆实数元素组织为无序向量或列表为O(n)的，无序向量或列表唯一化后判断是否元素唯一是O(n)的
故无序向量或列表唯一化问题有复杂度下界big-omega(nlogn)
sort+uniquify是一种取到该下界的算法