sequence: vector(array/linear array) + list
array/vector中的概念：
1.predecessor前驱：任意0<=i<j<n,A[i]为A[j]的前驱，其中A[j-1]为immediate predecessor直接前驱(要求j>=1),任一元素的所有前驱构成prefix前缀
  successor后驱：任意0<=j<i<n,A[i]为A[j]的后驱，其中A[j+1]为immediate successor(要求j<=n-2)，任一元素的所有后驱构成suffix后缀
2.call-by-rank 与call-by position等价： A[i]物理地址为A+i*s
  rank:元素的前驱个数
3.vector相较于array：不要求元素属于同一基本类型，甚至不见得同时具有某一数值属性，不保证能比较大小

4.无序向量：仅支持比对(T重载了==,!=),但未必支持比较的向量
  有序向量:元素支持比较，且所有元素按次序单调分布

5.排序的时间复杂度常系数主要取决于比较次数，也就是所谓的查找长度(search length)

6.排序算法的分类：
内部排序算法：数据规模内存足以容纳
外部排序算法：数据规模大，需要借助外部甚至分布式存储器，在排序计算过程中的任一时刻内存只能容纳其中一小部分数据

离线算法offline algorithm:输入数据以批处理形式整体给出
online algorithm：数据实时生成，算法启动后陆续到达

依赖体系结构：
串行算法
并行算法

是否采用随机策略：
确定式算法
随机式算法

本书介绍的主要是确定式串行脱机的内部排序算法

7.排序算法的稳定性stability:将向量A转为有序向量S后，设A[i]对应于S[k_i]
对任意A[i]==A[j],都有i<j当前仅当k_i<k_j,称为stable algorithm：数据实时生成，算法启动后陆续到达
稳定的排序算法可以实现对多个关键码key按照字典序的排序（先排优先级低的基数排序）

8.k-选取问题:
向量A排序后变S,A中各元素在S中的秩为r_i,选取r_i=k对应的元素的i，如果有雷同的元素则返回r_lo<=k<=r_hi中任一元素的i（都可以在排序后放在S[k]）
0-选取为selectMin (n-1)-选取为selectMax
中位数:n为奇数就是居中的那个，n为偶数为居中靠右的那个 n/2-选取问题：如果能高效寻找中位数将优化快速排序
 1.bruteforce:排序后找中位数，基于此的分治算法T(n)=nlogn+2T(n/2)=>T(n)=O(nlognlogn)难以接受
众数：要求该元素数目/n>0.5 众数一定是中位数，因此可以先找中位数，再判断是否为众数



排序问题中的定义：
1.序列A[0,n-1]中，若A[i-1]<=A[i]的相邻元素称为顺序的，否则是逆序的；
若对任意1<=i<n,有A[i-1]<=A[i]，则称为整体有序；反之，整体有序则所有相邻元素都局部有序

对n个整数的排序，最坏情况能否在小于O(n)的时间内完成？不能，至少每个元素要访问一次，如果所有元素都错位，每个元素至少比较或移动一次，结果输出也是O(n)
见List/线性规约一节可知CBA算法排序不小于O(nlogn)

算法的定义：有若干语义明确的基本操作组成的指令序列，每一基本操作在计算模型中可兑现（确定性和可行性），有穷性和正确性
  其中，有穷性和正确性的证明可能颇费周折
  hailstone问题：是否会成环或者序列长度无穷至今未证明，因此求hailstone序列或序列长度的程序不能严格称为算法
  证明技巧：寻找算法过程的不变性(归纳)和单调性（单调有界有穷）
      起泡排序：不变性：经过k次排序，前k大的元素必然就位 单调性：k次排序，待求解问题规模将缩减至n-k
  鲁棒性：退化(degeneracy)：一些极端输入，比如长度为负数，超过int最大值，A[]中元素全部相等，等等 鲁棒性(robustness)：处理退化情况的能力
  重用性：能否便捷地推广至其他场合
  可计算性/难解性
  计算效率：见线性规约一节关于复杂度的讨论
